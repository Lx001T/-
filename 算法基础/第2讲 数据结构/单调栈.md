# 单调栈

## 最常用的用法

有一个序列，找到某个数左边离它最近的，并且比它小的数。（可扩展）

~~有一个序列，找到某个数`右`边离它最近的，并且比它`大`的数。~~

## 模拟样例

![image-20221109083323362](https://cdn.jsdelivr.net/gh/Lx001T/my-imgs/jq2022/image-20221109083323362.png)

## 栈优化

在i指针向右枚举序列a[]过程中，每向右移动一位，可以把当前位置的元素加到栈里，枚举结束就可以把序列所有元素存储到栈里了！

$stack : \ a_1 \ a_2\ a_3\ …… a_{i-1}$

查看栈中是否存在某种单调性（是否存在某些数，永远不会作为答案）

**存在!**

如果$a_3 >= a_5$， 那么$a_3$永远不会作为答案输出。因为$a_5$在右边，并且比$a_3$小，满足离i(i>5)最近，并且更小。

可以用以下三段式说明（i>5）：

1. 如果 $a_3<a_i$
2. 因为 $a_3 <= a_5$
3. 则 $a_5<a_i$

**这就说明了如果$a_{i} >= a_j$ ，并且$i<j$，那么$a_j一定是更优答案，a_i永远不会作为答案输出$**

只要有这样的逆序关系，就可以把前面的数删掉，这个序列就一定是一个单调序列！

![image-20221109085618099](https://cdn.jsdelivr.net/gh/Lx001T/my-imgs/jq2022/image-20221109085618099.png)

这样向栈中插入元素的时候，只要满足$stk[tt] >= a[i]$，就可以把栈顶删掉！(stk[tt]是栈顶元素，a[i]是插进来的元素)

- 新插进来的元素**下标大于栈顶元素**
- 满足$stk[tt] >= i$

所以这两个数满足逆序关系，把前面的数(栈顶)删掉！

直到遇到栈中栈顶stk[tt] < a[i]的元素，则**此时的stk[tt]就是在a[i]左边，并且比a[i]小的数**，把栈顶输出，把a[i]插入栈中。

# 代码实现

```C++
#include <iostream>

using namespace std;

const int N = 100010;

int n; 
int stk[N], tt; // 栈和栈顶

int main()
{
    cin >> n;
    
    for (int i = 0; i < n; i ++ )
    {
        int x; // 序列元素
        cin >> x; 
        while (tt && stk[tt] >= x) tt -- ; // 如果栈顶存在，并且栈顶>=序列元素，删除栈顶
        if (tt) cout << stk[tt] << ' '; // 如果栈顶存在，输出栈顶
        else cout << "-1" << ' ';
        
        stk[ ++ tt] = x; // 满足条件把序列元素加到栈顶里
    }
    
    return 0;
}
```

