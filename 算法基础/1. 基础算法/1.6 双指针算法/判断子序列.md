# 题目描述

给定一个长度为 n 的整数序列 $a_1,a_2,…,a_n$以及一个长度为 m 的整数序列 $b_1,b_2,…,b_m$。

请你判断 a 序列是否为 b 序列的子序列。

子序列指序列的一部分项按**原有次序排列**而得的序列，例如序列 ${a_1,a_3,a_5}$ 是序列 ${a_1,a_2,a_3,a_4,a_5}$ 的一个子序列。

**输入格式**

第一行包含两个整数 n,m。

第二行包含 n 个整数，表示 $a_1,a_2,…,a_n$。

第三行包含 m 个整数，表示 $b_1,b_2,…,b_m$。

**输出格式**

如果 a 序列是 b 序列的子序列，输出一行 `Yes`。

否则，输出 `No`。

**数据范围**

$1≤n≤m≤10^5$,
$−10^9≤a_i,b_i≤10^9$

**输入样例：**

```
3 5
1 3 5
1 2 3 4 5
```

**输出样例：**

```
Yes
```

# 判断子序列

## 题意理解

有两个序列a, b，判断a是否是b的子序列。

如：`a: 1 2 3`，`b: 1 2 3 4 5`，则a是b的子序列。

此问题是经典的双指针问题，但是双指针能否使用需要证明。

**双指针算法能够判断a是不是b的子序列**，只要用两个指针从前到后把两个序列扫描一遍，看a的每个元素能否在b中找到匹配的元素，把b序列循环完，如果a中所有元素都被匹配，那么a是b的子序列，否则就不是。

## C++代码

```C++
#include <iostream>
#include <cstring>

using namespace std;

const int N = 100010;

int n, m;
int a[N], b[N];

int main()
{
    scanf("%d%d", &n, &m);
    
    for (int i = 0; i < n; i ++ ) scanf("%d", &a[i]);
    for (int j = 0; j < m; j ++ ) scanf("%d", &b[j]);
    
    int i = 0, j = 0;
    while (i < n && j < m)
    {
        if (a[i] == b[j]) i ++ ;
        j ++ ;
    }
    
    if (i == n) puts("Yes");
    else puts("No");
    
    return 0;
}
```

