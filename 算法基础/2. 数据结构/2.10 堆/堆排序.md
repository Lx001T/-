# 堆的概念

手写实现一个堆。维护一个数据集合。

堆的基本操作(STL可以直接实现)：`插入数`、`求集合最小值`、`删除最小值`

堆的基本操作(STL不能直接实现)：`删除任意任意一个数`、`修改任意一个数`

堆是一颗`完全二叉树`！

## 完全二叉树

百度百科解释：一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。

换成人话解释：除了最后一层，其他所有层的节点都是满的二叉节点，最后一层从左向右排列。

![image-20221124101311916](https://cdn.jsdelivr.net/gh/Lx001T/my-imgs/jq2022/image-20221124101311916.png)

## 堆的性质

以`小根堆`为例：小根堆的每个节点，都小于等于左右儿子。则根节点就是整棵树的最小值。

大根堆则相反。

## 堆的存储

用一个`一维数组`存(堆状数据结构都是用一维数组存)

下标从1开始！

如果从0开始，0的两倍还是0！不太方便，下标得变成2x+1,2x+2。

![image-20221124104052213](https://cdn.jsdelivr.net/gh/Lx001T/my-imgs/jq2022/image-20221124104052213.png)

举例说明：从根节点开始，从左向右，从上到下依次存储。

![image-20221124104320553](https://cdn.jsdelivr.net/gh/Lx001T/my-imgs/jq2022/image-20221124104320553.png)

## 堆的两个操作:up、down

堆的五个基本操作都可以用up、down两个操作实现。

### down

向下调整：把节点向下移

**基本逻辑:**将变大的数下移，每次将当前节点和其左右儿子比较，将节点与这三个数中最小的数交换。

![image-20221124110012590](https://cdn.jsdelivr.net/gh/Lx001T/my-imgs/jq2022/image-20221124110012590.png)

### up

向上调整：把节点向上移，操作同理。

![image-20221124110451961](https://cdn.jsdelivr.net/gh/Lx001T/my-imgs/jq2022/image-20221124110451961.png)

# 堆的基本操作

**如何用up和down两个操作实现这5种基本操作？**

## 插入一个数

插入节点x时，直接在堆的最后一个位置插入x，用up操作上移，直到不能移动为止。

![image-20221124110855566](https://cdn.jsdelivr.net/gh/Lx001T/my-imgs/jq2022/image-20221124110855566.png)

```C++
// heap[]表示存储堆的一维数组
// hsize表示当前堆的大小
// x表示要插入的元素
heap[ ++ hsize] = x;
up(hsize);
```

## 求集合中最小值

```C++
heap[1]; // 堆顶元素最小
```

## 删除最小值

用整个堆的最后一个元素，覆盖堆顶元素，把堆顶元素删除，再把堆顶元素down一遍。

因为在一维数组中，删除第一个元素是很难的，删除之后，后面的所有元素都需要向前挪动一位，但是删除最后一个元素很简单。

``` c++
heap[1] = heap[hsize]; // 用最后一个元素覆盖第一个元素
hsize -- ; // 删除最后一个元素
down(1); // 第一个元素down操作，保证小根堆的正确性
```

![image-20221124151834985](https://cdn.jsdelivr.net/gh/Lx001T/my-imgs/jq2022/image-20221124151834985.png)

## 删除任意一个元素

和删除最小值类似，但是把最后一个元素放到原第k个元素的位置，heap[hsize]的值与heap[k]的值有三种关系：

1. `heap[size] = heap[k] `：不用进行操作
2. `heap[hsize] > heap[k] `：进行down操作
3. `heap[hsize] < heap[k]`：进行up操作

但是进行代码实现时，可以不管三七二十一，把up和down操作都写上，这两个操作只能执行一个，只有`heap[hsize] > heap[k] `时，才能进行down操作。只有`heap[hsize] < heap[k] `时，才能进行up操作。

```C++
heap[k] = heap[hsize]; // 把最后一个位置的元素与第k个元素交换
size -- ; // 把最后一个元素删除
down(k); // down操作
up(k); // up操作
```

## 修改任意一个元素

和删除元素同理

```C++
heap[k] = x;
down(k);
up(k);
```

# 本题代码

## 题意理解

输入一个长度为 n 的整数数列，从小到大输出前 m 小的数。

首先得建堆，按照次序每次输出堆顶，输出堆顶之后，把堆顶删除，直到把堆做完。

因此只需要用到两个操作：删除最小值、求集合中的最小值。

求最小值的时间复杂度是O(1)的，插入和删除时间复杂度是$O(\log n)$

这两个操作只用到down操作。

## 代码解释

**建堆操作：**

一个一个往里插，进行建堆的操作，时间复杂度为$O(n \log n)$

插入的时间复杂度$O(\log n)$，一共有n步。

有一个时间复杂度为$O(n)$的建法：

```C++
// 从n/2开始，n/4,n/8…… 每个进行down操作，down的次数是
for (int i = n / 2; i; i -- ) down(1);
```

为什么时间复杂度是$O(n)$

![image-20221124164239394](https://cdn.jsdelivr.net/gh/Lx001T/my-imgs/jq2022/image-20221124164239394.png)

计算时间复杂度:

$0×\frac{n}{2}+1×\frac{n}{4}+2×\frac{n}{8}+3×\frac{n}{16}+……$

$=n×(\frac{1}{2^2}+\frac{2}{2^3}+\frac{3}{2^4}+\frac{4}{2^5}+……)$

$令S = (\frac{1}{2^2}+\frac{2}{2^3}+\frac{3}{2^4}+\frac{4}{2^5}+……)$

$则2S = (\frac{1}{2}+\frac{2}{2^2}+\frac{3}{2^3}+\frac{4}{2^4}+……)$

![image-20221124165018068](https://cdn.jsdelivr.net/gh/Lx001T/my-imgs/jq2022/image-20221124165018068.png)

$进行错位相减：2S-S =S= (\frac{1}{2}+\frac{1}{2^2}+\frac{1}{2^3}+\frac{1}{2^4}+……)=1-(\frac{1}{2})^n<1$

所以时间复杂度是小于O(n)的，也就是$O(n)级别$

## 代码如下

```C++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n, m; 
// h[N]表示存储堆的一维数组
// hsize是堆的长度，不能用size因为：size如果作为全局变量的话可能会重名。
int h[N], hsize;

void down(int u)
{
    int t = u; // 用t表示当前节点和它的左右儿子中的最小值
    // 如果左儿子小于当前节点，将左儿子替换上来
    if (u * 2 <= hsize && h[2 * u] < h[t]) t = u * 2;
    // 如果右儿子小于当前节点，将右儿子替换上来
    if (u * 2 + 1 <= hsize && h[2 * u + 1] < h[t]) t = u * 2 + 1; 
    
    
    if (u != t) // 如果当前节点不是最小的，将最小的交换上来，此时t被交换下去了，继续进行down操作
    {
        swap(h[u], h[t]);
        down(t);
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++) scanf("%d", &h[i]);
    hsize = n;
    
    for (int i = n / 2; i; i -- ) down(i);
    
    while (m -- )
    {
        printf("%d ", h[1]);
        // 下面三个操作是删除最小值，及数组第一个元素
        h[1] = h[hsize]; 
        hsize -- ;
        down(1);
    }
    
    return 0;
}
```

