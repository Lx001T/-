# 滑动窗口

## 样例模拟

有一个长度为n的数组，一个长度为k的滑动窗口，窗口每次向右滑动一格，求窗口内元素的最小值和最大值

![image-20221110134246887](https://cdn.jsdelivr.net/gh/Lx001T/my-imgs/jq2022/image-20221110134246887.png)

## 数据结构的选择

选择`queue`(队列)作为本题的数据结构，因为滑动窗口每次向右滑动的时候，要在队头插入一个新的元素，并且在队尾删除一个元素，队列正好符合这样的设定。

![image-20221110135010835](https://cdn.jsdelivr.net/gh/Lx001T/my-imgs/jq2022/image-20221110135010835.png)

`查询最小/大值`：每次遍历队列，找到最小值，最大值。

`时间复杂度`: O($nk$)

## 优化方法

查看是否具有单调性！

假定数组为a[]

在滑动窗口的内部，每次遍历队列取最小值，如果存在$a[i]>a[j],\ i < j$，那么a[i]就一定不会是最小值，并且在滑动窗口向右滑动的时候，a[i]同样不会是最小值，因为存在一个更小，并且更靠右的a[j]

![image-20221110140215540](https://cdn.jsdelivr.net/gh/Lx001T/my-imgs/jq2022/image-20221110140215540.png)

如下所示：

![image-20221110140717610](https://cdn.jsdelivr.net/gh/Lx001T/my-imgs/jq2022/image-20221110140717610.png)

在此窗口内，`-1`和`-3`满足$-1 >-3,且-1在-3左侧$，删除-1。`-3`和`5`不满足。

所以最小值就是队头`-3`

因此，在滑动窗口找最小值时，用**取队头元素**替代了**遍历滑动窗口找最小值**，成功将时间复杂度从O(k)优化到O(1)，整体时间复杂度从O($nk$)优化到O($n$)！

**做题思路：**

1. 用普通队列该怎么做
2. 将冗余元素删掉 -> 具有单调性
3. 可以用O(1)的时间从队头/队尾取出最值

**求最大值对称着做即可**

# 本题做法

**求最小值做法：**

先建立一个队列，每次向队尾插入元素，并且查看新插入元素是否比队尾元素小。

- 如果$队尾元素>新插入元素$，队尾元素出队。
- 如果$队尾元素<新插入元素$，新元素插入队列。

![image-20221110142223796](https://cdn.jsdelivr.net/gh/Lx001T/my-imgs/jq2022/image-20221110142223796.png)

**求最大值做法同理**

## 代码如下

```C++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1000010;

int n, k;
int a[N], q[N];

int main()
{
    cin >> n >> k;
    
    for (int i = 0; i < n; i ++ ) cin >> a[i];
    
    int hh = 0, tt = -1;
    for (int i = 0; i < n; i ++ )
    {
        if (hh <= tt && q[hh] < i - k + 1) hh ++ ;
        while (hh <= tt && a[q[tt]] >= a[i]) tt -- ;
        q[++ tt] = i;
        
        if (i >= k - 1) cout << a[q[hh]] << ' ';
    }
    
    puts("");
    
    hh = 0, tt = -1;
    for (int i = 0; i < n; i ++ )
    {
        if (hh <= tt && q[hh] < i - k + 1) hh ++ ;
        while (hh <= tt && a[q[tt]] <= a[i]) tt -- ;
        q[++ tt] = i;
        
        if (i >= k - 1) cout << a[q[hh]] << ' ';
    }
    
    return 0;
}
```

## 代码解析

**变量解释**

这里存储下标的思路非常妙，可以保证滑动窗口的大小是k！

下面代码可以说明。

```C++
int n, k; // n表示数组中有n个数， k表示滑动窗口的大小
int a[N], q[N]; // a[N]中存储元素值， q[N]中存储元素下标(相当于队列)
```

**求滑动窗口最小值**

```C++
int hh = 0, tt = -1; // hh为队头， tt为队尾
for (int i = 0; i < n; i ++ )
{
    if (hh <= tt && q[hh] < i - k + 1) hh ++ ; // 滑动窗口的大小是固定的，如果滑动窗口扫描过了某一个值，就把这个值删掉，见下图一
    while (hh <= tt && a[q[tt]] >= a[i]) tt -- ; // 如果队尾元素>=新插入元素，一直删到队尾元素小于新插入元素。
    q[++ tt] = i; // 把当前下标存到数组中

    if (i >= k - 1) cout << a[q[hh]] << ' '; // 当窗口的大小>=k的时候，开始输出最值。见下图二
}
```

![image-20221110145726775](https://cdn.jsdelivr.net/gh/Lx001T/my-imgs/jq2022/image-20221110145726775.png)

![image-20221110150410728](https://cdn.jsdelivr.net/gh/Lx001T/my-imgs/jq2022/image-20221110150410728.png)