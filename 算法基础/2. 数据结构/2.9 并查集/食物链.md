# 食物链

并查集可以维护额外信息，接下来看如何维护额外信息，如何维护好。

## 题目描述

动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。

A 吃 B，B 吃 C，C 吃 A。

现有 N 个动物，以 1∼N 编号。

每个动物都是 A,B,C 中的一种，但是我们并不知道它到底是哪一种。

有人用两种说法对这 N 个动物所构成的食物链关系进行描述：

第一种说法是 `1 X Y`，表示 X 和 Y 是同类。

第二种说法是 `2 X Y`，表示 X 吃 Y。

此人对 N 个动物，用上述两种说法，一句接一句地说出 K 句话，这 K 句话有的是真的，有的是假的。

当一句话满足下列三条之一时，这句话就是假话，否则就是真话。

1. 当前的话与前面的某些真的话冲突，就是假话；
2. 当前的话中 X 或 Y 比 N 大，就是假话；
3. 当前的话表示 X 吃 X，就是假话。

你的任务是根据给定的 N 和 K 句话，输出假话的总数。

**题意理解：**

![image-20221120191156969](https://cdn.jsdelivr.net/gh/Lx001T/my-imgs/jq2022/image-20221120191156969.png)

**样例模拟：**

![image-20221120192550051](https://cdn.jsdelivr.net/gh/Lx001T/my-imgs/jq2022/image-20221120192550051.png)

## 题目做法

并查集中每个集合是一个树的形式。

不管两种动物是`同类`还是`被吃`的关系，都把它们放在集合中，这样无论如何都能推理出三种动物的关系！

举例：

`x、y、z表示三个动物`  (这三个动物可能同类)

`用'-'表示同类，用'->'表示被吃`

$x-y:x和y是同类，\\ x \rightarrow y:x被y吃\ \ \ \ \ \ \ \ \ \  $

1. `x-y, y->z` => `x->z`：xy同类，y被z吃，则x被z吃。(只有两类动物)
2. `x->y, y->z` => `z->x`：x被y吃，y被z吃，则z被x吃。(三类动物构成一个环)

**那如何用树的形式存储，记录每个点之间的关系？**

记录每个点和根节点之间的关系，则可以知道任意两个点之间的关系。

用每个点到根节点的距离，确定它和根节点之间的关系。

因为只有三种动物，所以与根节点的关系循环周期为3！(再次注意：这三种动物被吃的关系是`环状`)

- x与根节点距离为1：x吃根节点
- x与根节点距离为2：根节点吃x
- x与根节点距离为3：与根节点同类

![image-20221122225110098](https://cdn.jsdelivr.net/gh/Lx001T/my-imgs/jq2022/image-20221122225110098.png)

因此，所有点到根节点的距离可以进行`%3`操作，有三个返回结果。(u表示根节点，x表示当前点)

1. `余0`：u与x同类
2. `余1`：x吃u
3. `余2`：u吃x

![image-20221122225556613](https://cdn.jsdelivr.net/gh/Lx001T/my-imgs/jq2022/image-20221122225556613.png)

**那距离是啥？**

有n种动物，其中包含x、y、z、k、g

![image-20221122230528548](https://cdn.jsdelivr.net/gh/Lx001T/my-imgs/jq2022/image-20221122230528548.png)

**那如何进行路径压缩？**

![image-20221122231221956](https://cdn.jsdelivr.net/gh/Lx001T/my-imgs/jq2022/image-20221122231221956.png)

**那如果通过距离判断两个点之间的关系？**

![image-20221122232241734](https://cdn.jsdelivr.net/gh/Lx001T/my-imgs/jq2022/image-20221122232241734.png)

# 代码如下

```C++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 50010;

int n, m;
int p[N], d[N];

int find(int x) // find函数返回的是每个点的根节点，加上了路径压缩操作，不是简单的递归
{
    // 注意：d[x]存的是x到父节点的距离，不是根节点。
    if (p[x] != x) // 如果父节点不是根节点
    {
        int t = find(p[x]); // 递归执行find函数
        d[x] += d[p[x]]; // 更新路径
        p[x] = t; // 再把父节点指向根节点
    }
    return p[x];
}

int main()
{
    scanf("%d%d", &n, &m);
    
    for (int i = 1; i <= n; i ++ ) p[i] = i;
    
    int res = 0; // 表示假话的个数
    while (m -- )
    {
        int t, x, y; // t表示两个动物的关系,1表示同类，2表示吃的关系
        scanf("%d%d%d", &t, &x, &y);
        
        if (x > n || y > n) res ++ ; // 如果动物类型超过所给的动物总数, 假话+1
        else
        {
            int px = find(x), py = find(y); // px表示x动物属于哪种集合
            if (t == 1) // x，y同类
            {
                if (px == py && (d[x] - d[y]) % 3 != 0) // 在一个集合中，并且表示两个动物距离根节点%3余数不相等
                    res ++ ; 
                else if (px != py) // 不在一个集合中
                {
                    p[px] = py; // 合并集合, 根节点px到py的距离用"?"表示
                    d[px] = d[y] - d[x]; // 表示它们是同类，由此等式推理得到：(d[x] + ?) % 3 == d[y] % 3
                }
            }
            else // x,y是吃的关系
            {
                if (px == py && (d[x] - d[y] - 1) % 3) // "!=" 被省略了，表示这两种动物不是被吃的关系
                    res ++ ; 
                else if (px != py)
                {
                    p[px] = py; // 合并集合，d[px]表示x的根节点p[x]到p[y]之间距离
                    d[px] = d[y] + 1 - d[x]; // 要表示y吃x，则y是x的下一代，(d[y] % 3) - (d[x] + ?) % 3 = 1
                }
            }
        }
    }
    
    printf("%d", res);
    
    return 0;
}
```

## 代码解释

**find函数解释**

```C++
int find(int x) // find函数返回的是每个点的根节点
{
    if (p[x] != x) // 如果父节点不是根节点
    {
        int t = find(p[x]); // 执行find函数
        d[x] += d[p[x]]; // 更新路径：find函数执行，一直递归执行find函数，直到最后一层回溯时，把所有路径距离更新，最后更新父节点。注意先后顺序！这样就成功路径压缩了
        p[x] = t; // 再把父节点指向根节点
    }
    return p[x];
}
```

![img](https://cdn.jsdelivr.net/gh/Lx001T/my-imgs/jq2022/1%7B35%7BD7VV@MEDMGKL_O~PAG.jpg)

**一些公式解释**

- `d[px] = d[y] + 1 - d[x];`

这个公式出现在：x、y是被吃关系，并且在两个不同的集合中。

由上可知，当y是根节点，x是y的下一代时，x吃y。

![image-20221123173127202](https://cdn.jsdelivr.net/gh/Lx001T/my-imgs/jq2022/image-20221123173127202.png)

- `(d[x] - d[y]) % 3 != 0`

判断`d[x]`和`d[y]`是否是同类

![image-20221123173742531](https://cdn.jsdelivr.net/gh/Lx001T/my-imgs/jq2022/image-20221123173742531.png)

不可以写成`d[x] % 3 != d[y] % 3`，由于有`d[px] = d[y] - d[x];`，距离可能会出现负数，用减法可以算出正确结果。但是直接判断，`-1`和`2`也是同一类，但是不相等。
