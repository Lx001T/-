此题和区间选点思路一样：[区间选点]([AcWing 905. 区间选点 - AcWing](https://www.acwing.com/solution/content/147530/))

# 题目对比

## 最大不相交区间数量

给定 N 个闭区间 $[a_i,b_i]$，请你在数轴上选择若干区间，使得选中的区间之间互不相交（包括端点）。

输出可选取区间的最大数量。

## 区间选点

给定 N 个闭区间 $[a_i,b_i]$，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。

输出选择的点的最小数量。

# 思路描述

**注意：由于题意的不同，思路产生微妙的区别**

## 最大不相交区间数量

1. 按照区间右端点从小到大进行排序
2. 从前往后依次枚举每个区间
   - 如果当前区间已经包含点，直接pass**(为了使两两区间不相交)**
   - 否则，选择当前区间的右端点

![image-20221114143407341](https://cdn.jsdelivr.net/gh/Lx001T/my-imgs/jq2022/image-20221114143407341.png)

## 区间选点

1. 按照区间右端点从小到大进行排序
2. 从前往后依次枚举每个区间
   - 如果当前区间已经包含点，直接pass**(为了选取尽可能少的点，覆盖所有区间)**
   - 否则，选择当前区间的右端点

![image-20221114143610018](https://cdn.jsdelivr.net/gh/Lx001T/my-imgs/jq2022/image-20221114143610018.png)

# 思路证明

两者思路是及其类似的，只不过有着微妙的区别。所以两者可以合并证明！

假定Ans是最终答案，cnt是根据上述思路所选取的区间数量。

**验证cnt就是最终答案，只需要证明cnt=Ans即可！**

(1) 先证明$Ans>=cnt$																			

Ans描述：最终答案是所选取的区间的最大数量

cnt描述：根据思路所选取的区间

显然Ans >= cnt

(2) 再证明$Ans<=cnt$

用反证法，假设$Ans>cnt$

根据上述思路，如果当前区间包含点，则直接pass，否则选择当前点。最终选取了cnt个点，把所有两两不相交的区间都覆盖掉了，每个区间至少包含一个选出来的两两不相交的点。

而$Ans>cnt$的意思是，最终结果是Ans，即要选出Ans个点去覆盖每个区间。但实际情况是选出cnt个点就可以覆盖每个区间了，$Ans>cnt$与实际情况不符。

所以可以得到：$Ans<=cnt$

综和(1)(2)可得：$Ans=Cnt$

# 代码如下

两个题目的代码完全一样，只不过理解方式有差异。

```C++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n;
struct Range// 定义一个结构体，存储左右端点
{
    int l, r;
    bool operator< (const Range &W)const // 用右端点重载小于号，方便后面按照右端点进行排序
    {
        return r < W.r;
    }
}Range[N]; 

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ )
    {
        int l, r;
        cin >> l >> r;
        Range[i] = {l, r}; // 载入左右端点
    }
    
    sort(Range, Range + n); // 按照右端点进行排序
    
    int res = 0, ed = -2e9; // res最终选取的点数量，ed是初始化的右端点：表示为负无穷
    for (int i = 0; i < n; i ++ ) // 从左到右枚举每个区间
        if (ed < Range[i].l) // 如果上一个区间的右端点严格小于当前区间的左端点
        {
            res ++ ; // 把这个区间选上
            ed = Range[i].r; // 更新一下右端点即可
        }
        
    printf("%d \n", res); // 输出答案
    
    return 0;
}
```

